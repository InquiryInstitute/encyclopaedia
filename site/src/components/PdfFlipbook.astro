---
/**
 * PDF Flipbook Component
 * 
 * Renders PDFs using PDF.js with a page-flip interface.
 * Falls back to standard PDF download if JS is unavailable.
 */
interface Props {
  pdfUrl: string;
  title: string;
  edition: 'adult' | 'children';
}

const { pdfUrl, title, edition } = Astro.props;
---

<section class="flipbook-container" data-edition={edition}>
  <header class="flipbook-header">
    <h1 class="flipbook-title">{title}</h1>
    <div class="flipbook-controls">
      <button id="prev-page" class="control-btn" aria-label="Previous page">
        ‚Üê Prev
      </button>
      <span id="page-indicator" class="page-indicator">
        Pages <span id="current-page">1-2</span> of <span id="total-pages">?</span>
      </span>
      <button id="next-page" class="control-btn" aria-label="Next page">
        Next ‚Üí
      </button>
    </div>
  </header>
  
  <div id="flipbook-viewport" class="flipbook-viewport">
    <div id="pageflip-container"></div>
    <div id="loading-indicator" class="loading-indicator">
      Loading PDF...
    </div>
  </div>
  
  <noscript>
    <div class="noscript-fallback">
      <p>JavaScript is required for the flipbook viewer.</p>
      <p><a href={pdfUrl} download>Download the PDF</a> to read offline.</p>
    </div>
  </noscript>
  
  <footer class="flipbook-footer">
    <a href={pdfUrl} download class="download-link">
      üì• Download PDF
    </a>
  </footer>
</section>

<script is:inline define:vars={{ pdfUrl }}>
  // Load PageFlip library from CDN (St.PageFlip)
  // Try multiple CDN sources for reliability
  const PAGEFLIP_CDN = 'https://cdn.jsdelivr.net/npm/st-pageflip@1.0.0/dist/st-pageflip.min.js';
  const PAGEFLIP_CDN_ALT = 'https://unpkg.com/st-pageflip@1.0.0/dist/st-pageflip.min.js';
  
  // PDF.js initialization using CDN
  const PDFJS_VERSION = '4.0.379';
  const PDFJS_CDN = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${PDFJS_VERSION}/pdf.min.mjs`;
  const PDFJS_WORKER = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${PDFJS_VERSION}/pdf.worker.min.mjs`;
  
  let pdfDoc = null;
  let pageFlip = null;
  let renderedPages = new Map();
  
  const container = document.getElementById('pageflip-container');
  const loadingIndicator = document.getElementById('loading-indicator');
  const currentPageSpan = document.getElementById('current-page');
  const totalPagesSpan = document.getElementById('total-pages');
  const prevBtn = document.getElementById('prev-page');
  const nextBtn = document.getElementById('next-page');
  
  async function init() {
    try {
      // Load PageFlip library (with fallback)
      await loadScript(PAGEFLIP_CDN, PAGEFLIP_CDN_ALT);
      
      // Load PDF.js from CDN
      const pdfjsLib = await import(PDFJS_CDN);
      pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER;
      
      // Load the PDF
      const loadingTask = pdfjsLib.getDocument(pdfUrl);
      pdfDoc = await loadingTask.promise;
      
      totalPagesSpan.textContent = pdfDoc.numPages;
      
      // Initialize PageFlip
      await initPageFlip();
      
      loadingIndicator.style.display = 'none';
      
      // Set up controls
      prevBtn.addEventListener('click', () => pageFlip.flipPrev());
      nextBtn.addEventListener('click', () => pageFlip.flipNext());
      
      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') pageFlip.flipPrev();
        if (e.key === 'ArrowRight') pageFlip.flipNext();
      });
      
    } catch (error) {
      console.error('Error loading PDF:', error);
      loadingIndicator.textContent = 'Error loading PDF. Please try the download link below.';
    }
  }
  
  function loadScript(src, altSrc = null) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = () => {
        if (altSrc) {
          // Try alternative CDN
          const altScript = document.createElement('script');
          altScript.src = altSrc;
          altScript.onload = resolve;
          altScript.onerror = () => reject(new Error(`Failed to load script from ${src} and ${altSrc}`));
          document.head.appendChild(altScript);
        } else {
          reject(new Error(`Failed to load script from ${src}`));
        }
      };
      document.head.appendChild(script);
    });
  }
  
  async function initPageFlip() {
    const numPages = pdfDoc.numPages;
    const pages = [];
    
    // Create page elements
    for (let i = 0; i < numPages; i++) {
      const pageDiv = document.createElement('div');
      pageDiv.className = 'page';
      pageDiv.dataset.pageNum = i + 1;
      
      const canvas = document.createElement('canvas');
      canvas.className = 'pdf-page-canvas';
      pageDiv.appendChild(canvas);
      
      pages.push(pageDiv);
      container.appendChild(pageDiv);
    }
    
    // Initialize PageFlip
    pageFlip = new St.PageFlip(container, {
      width: 600,
      height: 800,
      showCover: false,
      maxShadowOpacity: 0.5,
      drawShadow: true,
      flippingTime: 1000,
      usePortrait: true,
      startPage: 0,
      size: 'stretch',
      minWidth: 300,
      maxWidth: 1200,
      minHeight: 400,
      maxHeight: 1600,
    });
    
    // Render pages as needed
    pageFlip.on('flip', (e) => {
      const currentPage = e.data + 1;
      currentPageSpan.textContent = `${currentPage}${currentPage < numPages ? '-' + (currentPage + 1) : ''}`;
      
      // Render current and adjacent pages
      renderPageIfNeeded(currentPage);
      if (currentPage < numPages) renderPageIfNeeded(currentPage + 1);
      if (currentPage > 1) renderPageIfNeeded(currentPage - 1);
    });
    
    // Initial render
    renderPageIfNeeded(1);
    if (numPages > 1) renderPageIfNeeded(2);
    
    // Update button states
    pageFlip.on('flip', () => {
      prevBtn.disabled = pageFlip.getCurrentPageIndex() === 0;
      nextBtn.disabled = pageFlip.getCurrentPageIndex() >= numPages - 1;
    });
    
    // Calculate size based on viewport
    updatePageFlipSize();
    window.addEventListener('resize', () => {
      updatePageFlipSize();
    });
  }
  
  function updatePageFlipSize() {
    if (!pageFlip) return;
    
    const viewport = document.getElementById('flipbook-viewport');
    const maxWidth = viewport.clientWidth - 40;
    const maxHeight = viewport.clientHeight - 40;
    
    // Maintain aspect ratio (A4 is roughly 1.414:1)
    let width = Math.min(maxWidth, maxHeight * 1.414);
    let height = width / 1.414;
    
    if (height > maxHeight) {
      height = maxHeight;
      width = height * 1.414;
    }
    
    pageFlip.update();
  }
  
  async function renderPageIfNeeded(pageNum) {
    if (renderedPages.has(pageNum)) return;
    
    const pageElement = container.querySelector(`[data-page-num="${pageNum}"]`);
    if (!pageElement) return;
    
    const canvas = pageElement.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    
    try {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: 1.0 });
      
      // Calculate scale to fit page element
      const pageRect = pageElement.getBoundingClientRect();
      const scale = Math.min(
        (pageRect.width - 20) / viewport.width,
        (pageRect.height - 20) / viewport.height,
        2.0
      );
      
      const scaledViewport = page.getViewport({ scale });
      
      canvas.height = scaledViewport.height;
      canvas.width = scaledViewport.width;
      
      await page.render({
        canvasContext: ctx,
        viewport: scaledViewport
      }).promise;
      
      renderedPages.set(pageNum, true);
    } catch (error) {
      console.error(`Error rendering page ${pageNum}:`, error);
    }
  }
  
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>

<style>
  .flipbook-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
  }
  
  .flipbook-header {
    text-align: center;
    margin-bottom: 1.5rem;
  }
  
  .flipbook-title {
    font-family: 'Cormorant Garamond', Georgia, serif;
    font-size: 2rem;
    font-weight: 400;
    margin-bottom: 1rem;
    color: #c9a227;
  }
  
  .flipbook-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1.5rem;
  }
  
  .control-btn {
    padding: 0.5rem 1rem;
    border: 1px solid #c9a227;
    background: transparent;
    color: #f5f0e6;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .control-btn:hover:not(:disabled) {
    background: #c9a227;
    color: #1a1512;
  }
  
  .control-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
  
  .page-indicator {
    font-size: 0.9rem;
    color: #a89080;
  }
  
  .flipbook-viewport {
    position: relative;
    background: linear-gradient(180deg, #1a1512 0%, #2a1f18 50%, #1a1512 100%);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    margin-bottom: 1.5rem;
    min-height: 600px;
    max-height: 90vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    overflow: hidden;
  }
  
  #pageflip-container {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .page {
    background: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    box-sizing: border-box;
  }
  
  .pdf-page-canvas {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    display: block;
  }
  
  .loading-indicator {
    position: absolute;
    font-style: italic;
    color: #a89080;
  }
  
  .noscript-fallback {
    padding: 2rem;
    text-align: center;
    color: #f5f0e6;
  }
  
  .noscript-fallback a {
    color: #c9a227;
  }
  
  .flipbook-footer {
    text-align: center;
  }
  
  .download-link {
    color: #c9a227;
    text-decoration: none;
  }
  
  .download-link:hover {
    text-decoration: underline;
  }
  
  [data-edition="children"] .flipbook-title {
    color: #d4b5d4;
  }
</style>
